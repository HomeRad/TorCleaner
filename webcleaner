#!/usr/bin/python2.3
# -*- coding: iso-8859-1 -*-
#    Copyright (C) 2000,2001  Bastian Kleineidam
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
"""
            WebCleaner - a filtering HTTP proxy
	   =====================================


Features
--------
* HTTP/1.1 support
* integrated HTML parser, removes unwanted HTML (adverts, flash, etc.)
* integrated JavaScript engine, allows popup filtering
* compress documents on-the-fly (with gzip)
* disable animated GIFs
* filter images by size, removes banner adverts
* reduce images to low-bandwidth JPEGs
* remove/add/modify arbitrary HTTP headers
* usage of SquidGuard blacklists
* Basic, Digest and (untested) NTLM proxy authentication support
* per-host access control
* configurable over a themable web interface


Installing
----------
Read the file INSTALL


Why should I use WebCleaner?
----------------------------
The first feature that set WebCleaner apart from other proxies is
exact HTML filtering, and this removes a lot of advertisings.
The filter does not just replace some strings, the proxy parses all HTML
data into tags. The parser is fast (written in C) and can cope with every
broken HTML page out there; if the parser does not recognize HTML
structures, it just passes the data over to the browser until it recognizes
a tag again. No data is ever discarded or dropped by the parser.
The parser can also correct invalid HTML and even prevents some common
security risks like HTML buffer overflows (see ChangeLog for details).

The second thing is the Javascript filtering: Javascript data is
executed in the integrated Spidermonkey JS engine which is also used by
the Mozilla browser suite.
This eliminates all JavaScript obfuscation, popups, and document.write()
stuff, but the other JS functions still work as usual.


Configuration
-------------
Assuming your proxy runs on port 8080, point your browser to
http://localhost:8080/ to configure the proxy.
The underlying configuration format is a custom XML format which is
explained in config/filter.dtd and config/webcleaner.dtd.
Of course the default configuration is tuned to websites I visit
regularly. You can help me extend the current config data by sending
me patches!
If you installed from source or have the "webcleanertools" Debian
package installed, you can additionally run the GUI config tool
"webcleanerconf".


Running
-------
You can start the proxy by executing "webcleaner start".


Notes
-----
WebCleaner is _not_ a HTTP compliant proxy because it modifies requests,
headers and data! Modifications aside, the proxy tries to fulfill
the HTTP/1.1 specifications found in RFC 2616.

Surf performance will decrease, especially with the Rewriter and the
Replacer module enabled. It will decrease further with JavaScript
parsing enabled, since the proxy downloads and parses <script src="">
tags in the background.
WebCleaner is intended for a single user system; it does not scale well
beyond 5-10 users.

The Rewriter module parses the HTML. It optimizes HTML by making
tags and attribute names lowercase, quoting attribute values only
when necessary and removing some (but not all) ignorable whitespace.

The warning "unsupported content encoding" could lead to corrupted
HTML pages. WebCleaner tries to filter even unknown-encoded content
to prevent Denial of Service attacks (eg webservers sending always an
unknown content-encoding).
Currently, this affects only the "compress" or "x-compress" encoding,
because the LZW algorithm to uncompress such content is patented and
therefore not included in WebCleaner. See www.burnallgifs.org.


Credits
-------
The proxy code is based on the fourth incarnation of Amit's web proxy.

The filter code design is inspired from FilterProxy, a Perl program from
Bob McElrath <mcelrath+filterproxy@draal.physics.wisc.edu>.

Me, Bob and the author of AIFilter (Tels) had a nice discussion about
filter formats with good ideas. Tels convinced me to try stateful
filtering and I realize that it is very nice indeed.

Disabling animated GIFs is a question of honor, but the idea goes back to
the Webwasher.

The HTML parser is inspired from HotSAX.

CoAdvisor, for extracting all the important RFC stuff for non-caching
proxies in their test case documentation.

Colin Stewart for making simpleTAL.

What you can do
---------------
- Send me urls with adverts WebCleaner is not filtering.
- Send me urls that do not display correctly in WebCleaner.
- Implement something on the TODO list and send me a patch.
"""

__author__ = "Bastian Kleineidam"
__version__ = "$Revision$"[11:-2]
__date__    = "$Date$"[7:-2]

import sys, os
if sys.version[:5] < "2.3":
    raise SystemExit, "This program requires Python 2.3 or later."
try:
    import psyco
    psyco.profile()
except:
    pass
from wc import i18n, daemon

_usage = i18n._("""USAGE\twebcleaner command

COMMANDS
start
        Start the proxy. If it is already started, do nothing.
stop
        Stop the proxy. If it is already stopped, do nothing.
restart
        Try to stop the proxy, then start it.
reload
        If the proxy is running read the configuration files again.
        If it is not running, do nothing. (only supported under
        POSIX systems)
status
        Print info if the proxy is running or not.
startwatch
        Start a monitor program. If the proxy is not running, it
        starts the proxy again.
stopwatch
        Stop the monitor program and the proxy.""")


def _print_usage (msg):
    """print short usage info and exit"""
    print msg
    print i18n._("execute 'webcleaner -h' for help\n")
    sys.exit(1)



def _paginate (text, lines=22):
    """print text in pages of lines size"""
    textlines = text.split("\n")
    curline = 1
    for line in textlines:
        print line
        curline = curline + 1
        if curline >= lines and sys.stdin.isatty():
            curline = 1
            print i18n._("press return to continue...")
            sys.stdin.read(1)


def _print_help ():
    """print long usage info"""
    if os.name!='posix':
        _paginate(_usage)
    else:
        print _usage
    sys.exit(0)


def main ():
    # Read command line arguments
    import getopt
    try:
        # Note: cut out the name of the script
        options, args = getopt.getopt(sys.argv[1:], "h", ["help","pidfile="])
    except getopt.error:
        type, value = sys.exc_info()[:2]
        _print_usage(value)
    for opt,arg in options:
        if opt=="-h" or opt=="--help":
            _print_help()
        elif opt=='--pidfile':
            daemon.pidfile = arg
        else:
            _print_usage(i18n._("Unknown option %(option)s") % {'option':`opt`})
    if len(args) < 1:
        _print_usage(i18n._("No command given."))
    else:
        command=args[0]
        if len(args) > 1:
            print i18n._("warning: only first command is valid")
    # start the command
    if hasattr(daemon, command):
        msg, status = getattr(daemon, command)()
        if msg:
	    print >>sys.stderr, msg
        sys.exit(status)
    else:
        _print_usage(i18n._("Unknown command %s") % `command`)


def main_nt ():
    import win32serviceutil
    import win32service
    import win32event
    from wc import startfunc

    class PythonService (win32serviceutil.ServiceFramework):
        _svc_name_ = configdata.name
        _svc_display_name_ = configdata.description
        def __init__(self, args):
            win32serviceutil.ServiceFramework.__init__(self, args)
            # Create an event which we will use to wait on.
            # The "service stop" request will set this event.
            self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)

        def SvcStop(self):
            # Before we do anything, tell the SCM we are starting the stop process.
            self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
            # And set my event.
            win32event.SetEvent(self.hWaitStop)

        def SvcDoRun(self):
            import servicemanager
            # Log a "started" message to the event log.
            servicemanager.LogMsg(
               servicemanager.EVENTLOG_INFORMATION_TYPE,
               servicemanager.PYS_SERVICE_STARTED,
               (self._svc_name_,''))
            startfunc(self.hWaitStop)
            # Now log a "service stopped" message
            servicemanager.LogMsg(
               servicemanager.EVENTLOG_INFORMATION_TYPE,
               servicemanager.PYS_SERVICE_STOPPED,
               (self._svc_name_,''))

    # end class PythonService

    win32serviceutil.HandleCommandLine(PythonService)


if __name__ == '__main__':
    if os.name=='nt':
        main_nt()
    else:
        main()
