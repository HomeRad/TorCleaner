from docutils import writers, nodes, languages, utils
from docutils.writers import html4css1
from docutils.parsers.rst.directives.html import MetaBody

import sys, os

class NavInfo (object):
    """store nav info"""
    def __init__ (self, name, level, visible=True, order=sys.maxint):
        self.name = name
        self.level = level
        self.visible = visible
        self.order = order


    def export (self):
        """return machine-parseable navigation information, suitable
           for config files"""
        return "\n".join([
          "name = %r" % self.name,
          "level = %d" % self.level,
          "visible = %s" % self.visible,
          "order = %d" % self.order,
        ])


    def __str__ (self):
        return "[%d]%r %s order=%d"%\
          (self.level, self.name,
           (self.visible and "visible" or ""), self.order)


class Writer (html4css1.Writer):
    """writer using custom nav class"""
    def __init__ (self):
        writers.Writer.__init__(self)
        self.translator_class = HTMLFileNavTranslator


class HTMLNavTranslator (html4css1.HTMLTranslator):
    """ability to parse navigation meta info"""

    def __init__ (self, document):
        html4css1.HTMLTranslator.__init__(self, document)
        name = os.path.splitext(os.path.basename(self.settings._destination))[0]
        self.nav_info = NavInfo(name, 0)
        self.parse_meta_nav(document)
        self.process_meta_nav()


    def parse_meta_nav (self, document):
        # look for meta tags in document with nav info
        i = document.first_child_matching_class(MetaBody.meta)
        while i is not None:
            meta = document[i]
            if meta.attributes.get('name', '').startswith('navigation.'):
                self.add_meta_nav(meta.attributes)
            i = document.first_child_matching_class(MetaBody.meta, start=i+1)


    def process_meta_nav (self):
        pass


    def add_meta_nav (self, attributes):
        navattr = attributes['name'][11:]
        val = attributes['content']
        if navattr=='order':
            self.nav_info.order = int(val)
        elif navattr=='name':
            self.nav_info.name = val
        elif navattr=='visible':
            self.nav_info.visible = (val!='0')
        else:
            print >> sys.stderr, "unknown navigation attr", repr(navattr)


class HTMLFileNavTranslator (HTMLNavTranslator):
    """write .nav files and put navigation placeholder in html file"""

    def __init__ (self, document):
        HTMLNavTranslator.__init__(self, document)
        self.body_prefix = [
            self.get_nav_css(),
            self.get_topframe_bashing(),
             "</head>\n<body>\n",
            self.get_nav_placeholder(),
        ]
        self.body_suffix = [
            "</body>\n</html>\n",
        ]


    def get_topframe_bashing (self):
        return """<script type="text/javascript">
window.onload = function() {
  if (top.location != location) {
    top.location.href = document.location.href;
  }
}
</script>
"""


    def get_nav_placeholder (self):
        return "<bfk:navigation/>\n"


    def process_meta_nav (self):
        prefix = os.path.splitext(self.settings._destination)[0]
        nav = file(prefix+".nav", 'w')
        nav.write("# generated by htmlnav.py, do not edit\n")
        nav.write(self.nav_info.export())
        nav.write("\n")
        nav.close()


    def get_nav_css (self):
        p = self.settings.stylesheet_path.split("/")[:-1]
        p.append("navigation.css")
        p = "/".join(p)
        p = utils.relative_path(self.settings._destination, p)
        link = html4css1.HTMLTranslator.stylesheet_link
        return link % p

