--- /usr/share/doc/python2.3/examples/Tools/i18n/pygettext.py	2004-05-01 08:16:58.000000000 +0200
+++ pygettext.py	2004-05-05 22:25:33.000000000 +0200
@@ -12,6 +12,8 @@
 # directory (including globbing chars, important for Win32).
 # Made docstring fit in 80 chars wide displays using pydoc.
 #
+# 20030701 calvin@users.sf.net
+# added html parser
 
 # for selftesting
 try:
@@ -164,6 +166,8 @@
 import token
 import tokenize
 import operator
+import re
+import cgi
 
 __version__ = '1.5'
 
@@ -443,6 +447,9 @@
         self.__curfile = filename
         self.__freshmodule = 1
 
+    def has_entry (self, msg):
+        return self.__messages.has_key(msg)
+
     def write(self, fp):
         options = self.__options
         timestamp = time.ctime(time.time())
@@ -501,6 +508,110 @@
                 print >> fp, 'msgstr ""\n'
 
 
+from sets import Set
+import sgmllib
+
+class HtmlGettext (sgmllib.SGMLParser, object):
+    """handles all functions by printing the function name and
+       attributes"""
+    def __init__ (self, debug=0):
+        super(HtmlGettext, self).__init__()
+        self.tag = None
+        self.translations = Set()
+        self.data = ""
+
+
+    def unknown_starttag (self, tag, attributes):
+        attrs = {}
+        for key,val in attributes:
+            attrs[key] = val
+        self.i18nTranslate(tag, attributes, attrs)
+        self.i18nAttributes(tag, attributes, attrs)
+
+
+    def i18nAttributes (self, tag, attributes, attrs):
+        """add attribute values to translate"""
+        i18nval = attrs.get('i18n:attributes', None)
+        if i18nval == '':
+            # translate all attributes in this start tag
+            for key,val in attributes:
+                if ":" not in key: # skip namespace args
+                    self.translations.add(val)
+        elif i18nval is not None:
+            # translate given attributes
+            for name, msgid in get_attribute_list(i18nval):
+                if msgid.startswith("string:"):
+                    self.translations.add(msgid[7:].replace(';;', ';'))
+
+
+    def i18nTranslate (self, tag, attributes, attrs):
+        """add tag content to translate"""
+        i18nval = attrs.get('i18n:translate', None)
+        if i18nval == '':
+            if self.tag:
+                raise Exception, "nested i18n:translate is unsupported"
+            self.tag = tag
+            # search for tal:content and tal:replace string: vars
+            for key,val in attributes:
+                if key in ("tal:content", "tal:replace"):
+                    self.tag = None # tag content will be replaced
+                    if val.startswith("string:"):
+                        self.translations.add(val[7:].replace(';;', ';'))
+            self.data = ""
+        elif i18nval is not None:
+            if self.tag:
+                raise Exception, "nested i18n:translate is unsupported"
+            if i18nval.startswith("string:"):
+                self.translations.add(i18nval[7:].replace(';;', ';'))
+        elif self.tag:
+            # nested tag to translate
+            self.data += "<%s"%tag
+            for key,val in attributes:
+                self.data += " %s=\"%s\"" % (key, cgi.escape(val, True))
+            self.data += ">"
+
+
+    def unknown_endtag (self, tag):
+        if tag==self.tag:
+            self.translations.add(self.data)
+            self.tag = None
+            self.data = ""
+        elif self.tag:
+            self.data += "</%s>"%tag
+
+
+    def handle_data (self, data):
+        if self.tag:
+            self.data += data
+
+
+    def handle_charref (self, ref):
+        self.data += '&#%s;' % ref
+
+
+    def handle_entityref (self, ref):
+        self.data += '&%s;' % ref
+
+
+def get_attribute_list (argument):
+    # Break up the list of attribute settings
+    commandArgs = []
+    # We only want to match semi-colons that are not escaped
+    argumentSplitter =  re.compile('(?<!;);(?!;)')
+    for attributeStmt in argumentSplitter.split(argument):
+        #  remove any leading space and un-escape any semi-colons
+        attributeStmt = attributeStmt.lstrip().replace(';;', ';')
+        # Break each attributeStmt into name and expression
+        stmtBits = attributeStmt.split(' ')
+        if len(stmtBits) < 2:
+            # Error, badly formed attributes command
+            print >>sys.stderr, "Badly formed attributes command '%s'.  Attributes commands must be of the form: 'name expression[;name expression]'" % argument
+        attName = stmtBits[0]
+        attExpr = " ".join(stmtBits[1:])
+        commandArgs.append((attName, attExpr))
+    return commandArgs
+
+
 
 def main():
     global default_keywords
@@ -620,6 +731,7 @@
             expanded.extend(getFilesForName(arg))
     args = expanded
 
+    html_translations = Set()
     # slurp through all the files
     eater = TokenEater(options)
     for filename in args:
@@ -631,15 +743,21 @@
         else:
             if options.verbose:
                 print _('Working on %s') % filename
-            fp = open(filename)
+            fp = file(filename)
             closep = 1
         try:
-            eater.set_filename(filename)
-            try:
-                tokenize.tokenize(fp.readline, eater)
-            except tokenize.TokenError, e:
-                print >> sys.stderr, '%s: %s, line %d, column %d' % (
-                    e[0], filename, e[1][0], e[1][1])
+            if filename.endswith('.html'):
+                p = HtmlGettext()
+                p.feed(fp.read())
+                p.close()
+                html_translations.update(p.translations)
+            else:
+                eater.set_filename(filename)
+                try:
+                    tokenize.tokenize(fp.readline, eater)
+                except tokenize.TokenError, e:
+                    print >> sys.stderr, '%s: %s, line %d, column %d' % (
+                        e[0], filename, e[1][0], e[1][1])
         finally:
             if closep:
                 fp.close()
@@ -651,10 +769,14 @@
     else:
         if options.outpath:
             options.outfile = os.path.join(options.outpath, options.outfile)
-        fp = open(options.outfile, 'w')
+        fp = file(options.outfile, 'w')
         closep = 1
     try:
         eater.write(fp)
+        msgs = [msg for msg in html_translations if not eater.has_entry(msg)]
+        for msg in msgs:
+            print >> fp, 'msgid', normalize(msg)
+            print >> fp, 'msgstr ""\n'
     finally:
         if closep:
             fp.close()
